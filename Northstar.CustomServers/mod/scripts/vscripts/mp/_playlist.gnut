untyped
global function Playlist_Init
		
struct WeaponStruct {
	string name,
	bool   disabled,
	string	  mod1,
	string    mod2,
	array <string>   visor
} 

struct BoostStruct
{
	string name,
	bool   disabled
	int id
}

struct TitanStruct
{
	string name, 
	bool disabled,

	string passive1,
	string passive2,
	string passive3,

	//thanks monarch for making me  handle 3 seperet core passives
	string core1,
	string core2,
	string core3,

}

struct UniversalBan
{
	string name,
	bool disabled
}

struct {
 array<WeaponStruct> weaponArray 
 array<UniversalBan> grenadeArray
 array<UniversalBan> abilityArray
 array<BoostStruct> boostArray
 array<TitanStruct> titanArray
} file

void function Playlist_Init()
{
		print("__________                        __     __________      .__        __   ")
    print("\\______   \\_______   ____ _____  |  | __ \\______   \\____ |__| _____/  |_ ")
    print(" |    |  _/\\_  __ \\_/ __ \\\\__  \\ |  |/ /  |     ___/  _ \\|  |/    \\   __\\")
    print(" |    |   \\ |  | \\/\\  ___/ / __ \\|    <   |    |  (  <_> )  |   |  \\  |  ")
    print(" |______  / |__|    \\___  >____  /__|_ \\  |____|   \\____/|__|___|  /__|  ")
    print("        \\/              \\/     \\/     \\/                         \\/      ")
    print("A")
	print(GetPlayerArray().len())
	foreach(entity player in GetPlayerArray())
	{
		Remote_CallFunction_NonReplay( player, "ServerCallback_BanTest" )
		//GetTitanLoadoutForPlayer(player)
		//player.SetPersistentVar( "burnmeterSlot", 0 )
		
	}
	// featured mode settings
	AddCallback_OnPlayerRespawned( FeaturedModeSettingsSetupPilotLoadouts )
	
	AddCallback_GameStateEnter( eGameState.Playing, OnGamestartModeSettings)

	AddCallback_OnUpdateDerivedPlayerTitanLoadout(CheckTitan)

	// iron lts rules
	if ( HasIronRules() ) 
		Riff_ForceTitanExitEnabled( eTitanExitEnabled.Never )


	InitGrenadeArray()
	InitAbilityArray()
	InitWeaponArray()
	InitBoostArray()
	InitTitanArray()

	#if SERVER
		print("Server")
	#endif

	#if MP
		print("MP")
	#endif

	#if CLIENT
		print("CLIENT")
	#endif

	#if UI
		print("UI")
	#endif

	AddCallback_GameStateEnter( eGameState.Playing, TitanEarning_OnPlaying )
}

void function TitanEarning_OnPlaying()
{
    WaitFrame() // Wait a frame to make sure the normal earn meter setting is done and doesn't override our one.

    Riff_ForceTitanAvailability( eTitanAvailability.Custom )
    svGlobal.titanAvailabilityCheck = IsTitanAvailable

    SetCallback_EarnMeterGoalEarned( TitanEarning_TitanEarned )
	SetCallback_EarnMeterRewardEarned( BoostEarning_TitanEarned )
}

void function BoostEarning_TitanEarned( entity player )
{
	if( GetFirstAvailableBoost().name != "Null" ) //check if boosts are disabled
	{
		EarnObject earnobject = PlayerEarnMeter_GetReward( player )
		BurnReward burncard = BurnReward_GetByRef( earnobject.ref )

		while ( burncard.ref == "burnmeter_random_foil" )
			burncard = BurnReward_GetRandom()

		for ( int i = 0; i < BurnMeter_GetLimitedRewardCount( player ); i++ )
			BurnMeter_GiveRewardDirect( player, burncard.ref )

		PlayerEarnMeter_DisableReward( player )
	} 
}

void function TitanEarning_TitanEarned( entity player )
{
    if ( GetFirstAvailableTitan().name != "Null" ) //Check if all titans are banned
        SetTitanAvailable( player )
    else
    {
        float oldRewardFrac = PlayerEarnMeter_GetRewardFrac( player )
        PlayerEarnMeter_Reset( player )
        PlayerEarnMeter_SetRewardFrac( player, oldRewardFrac )
        PlayerEarnMeter_EnableReward( player )
    }
}

bool function IsFeaturedMode( string modeName  )
{
	return GetCurrentPlaylistVar( "featured_mode_" + modeName ) == "1"
}

void function OnGamestartModeSettings()
{
	foreach (entity player in GetPlayerArray())
	{
		FeaturedModeSettingsSetupPilotLoadouts(player)
	}
}

void function FeaturedModeSettingsSetupPilotLoadouts( entity player)
{
	Remote_CallFunction_NonReplay( player, "ServerCallback_BanTest" )
	if ( IsFeaturedMode( "all_holopilot" ) || IsFeaturedMode( "all_grapple" ) || 
		 IsFeaturedMode( "all_phase" ) || IsFeaturedMode( "all_ticks" ) || 
		 IsFeaturedMode( "rocket_arena" ) || IsFeaturedMode( "shotguns_snipers" ) || 
		 IsFeaturedMode( "tactikill" ) || IsFeaturedMode( "amped_tacticals" )||IsFeaturedMode( "BanLogicTest" )  )
		 SetLoadoutGracePeriodEnabled( false )
	

	if ( GetGameState() == eGameState.Prematch )
	{
		return
	}
	else if(player.IsTitan())
	{
		return
	}

	bool shouldChangeLoadout = false


	// create loadout struct
	PilotLoadoutDef modifiedLoadout = clone GetActivePilotLoadout( player )

	if ( IsFeaturedMode( "all_holopilot" ) )
	{
		shouldChangeLoadout = true 
		
		modifiedLoadout.special = "mp_ability_holopilot"
	}
		
	if ( IsFeaturedMode( "all_grapple" ) ) 
	{
		shouldChangeLoadout = true 
		
		modifiedLoadout.special = "mp_ability_grapple"
		modifiedLoadout.specialMods = [ "all_grapple" ]
	}
		
	if ( IsFeaturedMode( "all_phase" ) ) 
	{
		shouldChangeLoadout = true 
		
		modifiedLoadout.special = "mp_ability_shifter"
		modifiedLoadout.specialMods = [ "all_phase" ]
	}
		
	if ( IsFeaturedMode( "all_ticks" ) ) 
	{
		shouldChangeLoadout = true 
		
		modifiedLoadout.ordnance = "mp_weapon_frag_drone"
		modifiedLoadout.ordnanceMods = [ "all_ticks" ]
	}
	
	if ( IsFeaturedMode( "rocket_arena" ) )
	{	
		// this crashes sometimes for some reason
	
		shouldChangeLoadout = true
	
		// have to set attachments too, otherwise we could give invalid mods for this weapon
		modifiedLoadout.primary = "mp_weapon_epg"
		modifiedLoadout.primaryMods = [ "rocket_arena" ]
		modifiedLoadout.primaryAttachments = [ "" ]
		
		// set secondary to whatever one is pistol
		if ( GetWeaponInfoFileKeyField_Global( player.GetMainWeapons()[ 1 ].GetWeaponClassName(), "menu_category" ) == "at" )
		{
			modifiedLoadout.weapon3 = "mp_weapon_autopistol"
			modifiedLoadout.weapon3Mods = [ "rocket_arena" ]
		}
		else
		{
			modifiedLoadout.secondary = "mp_weapon_autopistol"
			modifiedLoadout.secondaryMods = [ "rocket_arena" ]
		}
		
		modifiedLoadout.meleeMods = [ "rocket_arena" ]
		
		player.GiveExtraWeaponMod( "rocket_arena" )
	}
	
	if ( IsFeaturedMode( "shotguns_snipers" ) )
	{
	
		shouldChangeLoadout = true 
		
		// this one was never released, assuming it just gives you a mastiff and a kraber with quick swap
		modifiedLoadout.primary = "mp_weapon_sniper"
		modifiedLoadout.primaryMods = [ "pas_fast_swap", "pas_fast_ads" ]
		modifiedLoadout.primaryAttachments = [ "" ]
		
		// set secondary to whatever one is pistol
		if ( GetWeaponInfoFileKeyField_Global( player.GetMainWeapons()[ 1 ].GetWeaponClassName(), "menu_category" ) == "at" )
		{
			modifiedLoadout.weapon3 = "mp_weapon_mastiff"
			modifiedLoadout.weapon3Mods = [ "pas_fast_swap", "pas_run_and_gun" ]
		}
		else
		{
			modifiedLoadout.secondary = "mp_weapon_mastiff"
			modifiedLoadout.secondaryMods = [ "pas_fast_swap", "pas_run_and_gun" ]
		}
	}

	// Weapon ban vars 
	bool shouldRemovePrim = false
	bool shouldRemoveSec = false
	bool shouldRemoveAbility = false
	bool shouldRemoveWeapon3 = false
	bool shouldRemoveGrenade = false
	
	bool EditedKit = false
	string message  = "Your Kit used Baned weapons: \n"

	if(true) //TODO Fix this
	{
		shouldChangeLoadout = true 

		WeaponStruct weapon


		////////////////////////////////////////////////////////////////////////////////////// 
		///////////////////   Loops to ban weapon  DeV stuff
		//////////////////////////////////////////////////////////////////////////////////////
		
		//weapon
		for(int i = 0; i < 15; i++){
			//file.weaponArray[i].disabled = true
			file.weaponArray[i].mod1 =  "pas_fast_ads"
			file.weaponArray[i].mod2 = "pas_fast_reload"
		} 

		for(int i = 0; i < 12; i++){
		file.weaponArray[i].disabled = true
		} 

		for(int i = 26; i < 28; i++){
		file.weaponArray[i].disabled = true
		} 
		// Ability
		for(int i = 0; i < 5; i++){
		file.abilityArray[i].disabled = true
		} 
		// nades
		for(int i = 0; i < 2; i++){
		file.grenadeArray[i].disabled = true
		} 

		//titans
		for(int i = 0; i < 7; i++)
		{
			file.titanArray[i].disabled = true
		}

		// boostes 
		for(int i = 0; i < file.boostArray.len(); i++)
		{
		   file.boostArray[i].disabled = true
		} 

		////////////////////////////////////////////////////////////////////////////////////// 
		///////////////////   Using Code 
		//////////////////////////////////////////////////////////////////////////////////////--

		for(int CheckingWeapon = 0; CheckingWeapon < file.weaponArray.len(); CheckingWeapon++ )
		{

			WeaponStruct weapon = file.weaponArray[CheckingWeapon]

			//check Primary
			if(modifiedLoadout.primary == weapon.name && weapon.disabled)
			{
				printt("----------------------------------- changed prim")
				EditedKit = true

				
				WeaponStruct newWeapon = GetFirstAvailablePrimaryWeapon()
				if (newWeapon.name != "Null" )
				{ 
					modifiedLoadout.primary = newWeapon.name
					message += "primary changet to: " + newWeapon.name +" \n"
					// if mod1 is forced && mod 2 is free and its the same as forced mod1 we ignore it, but you can do it if  you want  tf2 wont crash
					if( newWeapon.mod1 != "UNDEFINED")
					{
						modifiedLoadout.primaryMods[0] = newWeapon.mod1
						modifiedLoadout.primaryAttachments = newWeapon.visor
					}

					if( newWeapon.mod2 != "UNDEFINED")
					{
						modifiedLoadout.primaryMods[1] = newWeapon.mod2
						modifiedLoadout.primaryAttachments = newWeapon.visor
					}	
				}
				else
				{
					shouldRemovePrim = true
					message += "Primary Removed \n"
				}

			}
			//check Secondary Slot
			else if(modifiedLoadout.secondary == weapon.name && weapon.disabled)
			{
				printt("----------------------------------- changed SEC ")
				EditedKit = true


				 WeaponStruct  newWeapon

				if ( GetWeaponInfoFileKeyField_Global( player.GetMainWeapons()[ 1 ].GetWeaponClassName(), "menu_category" ) == "at" )
				{
				   newWeapon = GetFirstAvailableAtWeapon()
				}
				else
				{
			       newWeapon = GetFirstAvailableSecWeapon()
				}
				
				if (newWeapon.name != "Null" )
				{ 
					modifiedLoadout.secondary = newWeapon.name
					message += "Secondary changet to: " + newWeapon.name +" \n"

					// if mod1 is forced && mod 2 is free and its the same as forced mod1 we ignore it, but you can do it if  you want  tf2 wont crash
					if( weapon.mod1 != "UNDEFINED")
					{
						modifiedLoadout.secondaryMods[0] = newWeapon.mod1
					}

					if( weapon.mod2 != "UNDEFINED")
					{
						modifiedLoadout.secondaryMods[1] = newWeapon.mod2
					}	
				}
				else
				{
					shouldRemoveSec = true
					message += "Secondary Removed \n"
				}
			}
				//check 3rd Slot
			else if(modifiedLoadout.weapon3 == weapon.name && weapon.disabled)
			{
				printt("----------------------------------- changed weapon 3")
				EditedKit = true
				WeaponStruct  newWeapon
 				if ( GetWeaponInfoFileKeyField_Global( player.GetMainWeapons()[ 2 ].GetWeaponClassName(), "menu_category" ) == "at" )
				{
				   newWeapon = GetFirstAvailableAtWeapon()
				}
				else
				{
			       newWeapon = GetFirstAvailableSecWeapon()
				}
				
				if (newWeapon.name != "Null" )
				{ 
					modifiedLoadout.weapon3 = newWeapon.name
					
					message += "Weapon 3 changet to: " + newWeapon.name +" \n"

					if( newWeapon.mod1 != "UNDEFINED")
					{
						modifiedLoadout.weapon3Mods[0] = newWeapon.mod1
					}

					if( newWeapon.mod2 != "UNDEFINED")
					{
						modifiedLoadout.weapon3Mods[1] = newWeapon.mod2
					}	
				}
				else
				{
					shouldRemoveWeapon3 = true
					message += "Weapon 3 Removed \n"
				}
			}
			if(modifiedLoadout.primary == weapon.name && (weapon.mod1 != "UNDEFINED" || weapon.mod2 != "UNDEFINED" ))
			{
				modifiedLoadout.primaryMods[0] = weapon.mod1
				modifiedLoadout.primaryMods[1] = weapon.mod2
				modifiedLoadout.primaryAttachments = weapon.visor
			}
			if(modifiedLoadout.secondary == weapon.name && (weapon.mod1 != "UNDEFINED" || weapon.mod2 != "UNDEFINED" ))
			{
				modifiedLoadout.secondaryMods[0] = weapon.mod1
				modifiedLoadout.secondaryMods[1] = weapon.mod2
			}
			if(modifiedLoadout.weapon3 == weapon.name && (weapon.mod1 != "UNDEFINED" || weapon.mod2 != "UNDEFINED" ))
			{
				modifiedLoadout.weapon3Mods[0] = weapon.mod1
				modifiedLoadout.weapon3Mods[1] = weapon.mod2
			}
		}

		// Granades
		for(int i = 0; i < file.grenadeArray.len(); i++)
		{
			UniversalBan grenade = file.grenadeArray[i]
			if(grenade.name == modifiedLoadout.ordnance)
			{
				if(grenade.disabled) 
				{
					printt("----------------------------------- changed Grenade")
					EditedKit = true
					UniversalBan newUniversalBan = GetFirstAvailableGrenade()
				
					if(newUniversalBan.name != "Null")
					{
				    	modifiedLoadout.ordnance = newUniversalBan.name
						message += " Ordanace changed to " + newUniversalBan.name +  " \n"
					}
					else
					{
						shouldRemoveGrenade = true
						message += "Granades Removed \n"
					}
				}
				break
			} 
		}

		//Ability
		for(int i = 0; i < file.abilityArray.len(); i++)
		{
			UniversalBan ability =  file.abilityArray[i]
			if(ability.name == modifiedLoadout.special)
			{
				if(ability.disabled) {
					EditedKit = true
					UniversalBan NewAbilityStruct = GetFirstAvailableAbility()

					if(NewAbilityStruct.name != "Null" )
					{
				 		modifiedLoadout.special = NewAbilityStruct.name
				 		message += "Abillity changed to "+ NewAbilityStruct.name  + " \n"
					}
					else
					{
				 		shouldRemoveAbility = true
				 		message += "Ability Removed  \n"
					}
				}
				break
			}
		}

		//boost
		BoostStruct currentBoost = GetBoostStructById(player.GetPersistentVar("burnmeterSlot"))
		if(currentBoost.disabled) 
		{
			BoostStruct newBoost = GetFirstAvailableBoost()

			if(newBoost.name != "Null")
			{
				EditedKit = true
				player.SetPersistentVar( "burnmeterSlot", newBoost.id )
				message += "Boost changed to "+ newBoost.name  + " \n"
			}
		}
	}
	
	// dont wanna give a new loadout if it's not necessary, could break other callbacks
	if ( shouldChangeLoadout )
		GivePilotLoadout( player, modifiedLoadout )


	if(shouldRemovePrim)
	{
		player.TakeWeapon(modifiedLoadout.primary)
	}

	if(shouldRemoveSec)
	{
		player.TakeWeapon(modifiedLoadout.secondary)
	}

	if(shouldRemoveWeapon3)
	{
		player.TakeWeapon(modifiedLoadout.weapon3)
	}

	if(shouldRemovePrim &&  shouldRemoveSec && shouldRemoveWeapon3)
	{
		player.GiveWeapon("mp_weapon_rocket_launcher")
		player.SetActiveWeaponByName( "mp_weapon_rocket_launcher" )
	}
	
	if(shouldRemoveGrenade)
		player.TakeOffhandWeapon( OFFHAND_ORDNANCE )
	
	if(shouldRemoveAbility)
		player.TakeOffhandWeapon( OFFHAND_SPECIAL )
	
	if(EditedKit)
		SendHudMessage( player, message, 2.5,-2.5,255,0,0, 255, 0, 4, 1 )


	if ( IsFeaturedMode( "tactikill" ) )
		player.GiveExtraWeaponMod( "tactical_cdr_on_kill" )
	
	if ( IsFeaturedMode( "amped_tacticals" ) )
		player.GiveExtraWeaponMod( "amped_tacticals" )

}

WeaponStruct function GetFirstAvailablePrimaryWeapon()
{
	for(int i = 0; i < 23; i++ )
	{
		WeaponStruct CurrentCheckingWeapon  =	file.weaponArray[i]
		
		if(CurrentCheckingWeapon.disabled == false)
		{

			return CurrentCheckingWeapon
			
		}
	}

	return createWeaponStruct("Null")
}


WeaponStruct function GetFirstAvailableSecWeapon()
{
 for(int i = 23; i < 26; i++ )
	{
		WeaponStruct CurrentCheckingWeapon  =	file.weaponArray[i]
		
		if(CurrentCheckingWeapon.disabled == false)
		{

			return  CurrentCheckingWeapon
		}
	}
	
	return createWeaponStruct("Null")
}

WeaponStruct function GetFirstAvailableAtWeapon()
{
 for(int i = 27; i < 30; i++ )
	{
		WeaponStruct CurrentCheckingWeapon  =	file.weaponArray[i]
		
		if(CurrentCheckingWeapon.disabled == false)
		{
			return CurrentCheckingWeapon
			
		}
	}

	return createWeaponStruct("Null")
}

UniversalBan function GetFirstAvailableGrenade()
{
	
	for(int i = 0; i < file.grenadeArray.len(); i++)
	{
		UniversalBan CurrentCheckingGrenade = file.grenadeArray[i]
		if(CurrentCheckingGrenade.disabled == false)
		{
			return CurrentCheckingGrenade
		}
	}

	return createUniversalBan("Null")
}

UniversalBan function GetFirstAvailableAbility()
{
	for(int i = 0; i < file.abilityArray.len(); i++)
	{
		UniversalBan CurrentCheckingAbility = file.abilityArray[i]
		if(CurrentCheckingAbility.disabled == false)
		{
			return CurrentCheckingAbility
		}
	}

	return createUniversalBan("Null")
}

BoostStruct function GetFirstAvailableBoost()
{
	for(int i = 0; i < file.boostArray.len(); i++)
	{
		BoostStruct CurrentCheckingBoost = file.boostArray[i]
		if(CurrentCheckingBoost.disabled == false)
		{
			return CurrentCheckingBoost
		}
	}
	return createBoostStruct("Null", 0)
}

TitanStruct function GetFirstAvailableTitan()
{
	
	for(int i = 0; i < file.titanArray.len(); i++)
	{
		TitanStruct CurrentCheckingTitan = file.titanArray[i]
		if(!CurrentCheckingTitan.disabled)
		{
			return CurrentCheckingTitan
		}
	}
	return createTitanStruct("Null")
}

void function InitGrenadeArray()
{
	file.grenadeArray.append(createUniversalBan("mp_weapon_frag_grenade"))
	file.grenadeArray.append(createUniversalBan("mp_weapon_grenade_emp"))
	file.grenadeArray.append(createUniversalBan("mp_weapon_thermite_grenade"))
	file.grenadeArray.append(createUniversalBan("mp_weapon_grenade_gravity"))
	file.grenadeArray.append(createUniversalBan("mp_weapon_grenade_electric_smoke"))
	file.grenadeArray.append(createUniversalBan("mp_weapon_satchel"))
}

void function InitAbilityArray()
{
	file.abilityArray.append(createUniversalBan("mp_ability_cloak"))
	file.abilityArray.append(createUniversalBan("mp_weapon_grenade_sonar"))
	file.abilityArray.append(createUniversalBan("mp_ability_grapple"))
	file.abilityArray.append(createUniversalBan("mp_ability_heal"))
	file.abilityArray.append(createUniversalBan("mp_weapon_deployable_cover"))
	file.abilityArray.append(createUniversalBan("mp_ability_shifter"))
	file.abilityArray.append(createUniversalBan("mp_ability_holopilot"))
}

UniversalBan function createUniversalBan(string name) 
{
	UniversalBan newStruct
	newStruct.name = name
	newStruct.disabled = false
	return newStruct
}

void function InitWeaponArray()
{
	//index 0-29 
	//index 0 - 22 primary
	//index 23 - 25 sec
	// index 26 - 29 at
	file.weaponArray.append(createWeaponStruct("mp_weapon_rspn101"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_rspn101_og"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_hemlok"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_g2"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_vinson"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_car"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_alternator_smg"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_hemlok_smg"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_r97"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_lmg"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_lstar"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_esaw"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_sniper"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_doubletake"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_dmr"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_shotgun"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_mastiff"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_smr"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_epg"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_softball"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_pulse_lmg"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_wingman_n"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_shotgun_pistol"))

	file.weaponArray.append(createWeaponStruct("mp_weapon_autopistol"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_semipistol"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_wingman"))

	
	file.weaponArray.append(createWeaponStruct("mp_weapon_defender"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_mgl"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_arc_launcher"))
	file.weaponArray.append(createWeaponStruct("mp_weapon_rocket_launcher"))
}

WeaponStruct function createWeaponStruct(string name) 
{
	WeaponStruct newStruct 
	newStruct.name = name 
	newStruct.disabled = false
	newStruct.mod1 = "UNDEFINED"
	newStruct.mod2 = "UNDEFINED"
	newStruct.visor = [""]

	return newStruct
}

void function InitBoostArray()
{
	file.boostArray.append(createBoostStruct("burnmeter_maphack" , 0))
	file.boostArray.append(createBoostStruct("burnmeter_amped_weapons" , 1))
	file.boostArray.append(createBoostStruct("burnmeter_ticks" , 2))
	file.boostArray.append(createBoostStruct("burnmeter_random_foil" , 3))
	file.boostArray.append(createBoostStruct("burnmeter_ap_turret_weapon" , 4))
	file.boostArray.append(createBoostStruct("burnmeter_phase_rewind" , 5))
	file.boostArray.append(createBoostStruct("burnmeter_at_turret_weapon" , 6))
	file.boostArray.append(createBoostStruct("burnmeter_holopilot_nova" , 7))
	file.boostArray.append(createBoostStruct("burnmeter_emergency_battery" , 8))
	file.boostArray.append(createBoostStruct("burnmeter_smart_pistol" , 9))
	file.boostArray.append(createBoostStruct("burnmeter_radar_jammer" , 10))
	file.boostArray.append(createBoostStruct("burnmeter_hard_cover" , 11))
}

BoostStruct function createBoostStruct(string name, int id) 
{
	BoostStruct newStruct
	newStruct.name = name
	newStruct.disabled = false
	newStruct.id = id
	return newStruct
}

void function InitTitanArray()
{
	file.titanArray.append(createTitanStruct("ion"))
	file.titanArray.append(createTitanStruct("scorch"))
	file.titanArray.append(createTitanStruct("northstar"))
	file.titanArray.append(createTitanStruct("ronin"))
	file.titanArray.append(createTitanStruct("tone"))
	file.titanArray.append(createTitanStruct("legion"))
	file.titanArray.append(createTitanStruct("vanguard"))
}

TitanStruct function createTitanStruct(string name) 
{
	TitanStruct newStruct
	newStruct.name = name
	newStruct.disabled = false
	newStruct.passive1 = "UNDEFINED"
	newStruct.passive2 = "UNDEFINED"
	newStruct.passive3 = "UNDEFINED"
	newStruct.core1 = "UNDEFINED"
	newStruct.core2 = "UNDEFINED"
	newStruct.core3 = "UNDEFINED"
	return newStruct
}


void function CheckTitan(entity player,TitanLoadoutDef currentTitanLoadout)	
{
	bool shouldChangeTitanLoadout = false
	int titanLoadoutIndex
	
	if(GetTitanStructByName(currentTitanLoadout.titanClass).disabled)
	{

	 TitanStruct	titanStruct  = GetFirstAvailableTitan()
		
		if(titanStruct.name == "Null")
		{
			svGlobal.forceDisableTitanfalls = false
			return
		}
		 //titanLoadoutIndex = GetTitanLoadoutIndexByName(titanStruct.name)

	 print("------ Changet Titan to " + titanStruct.name)
	
	 shouldChangeTitanLoadout = false
	} 
	else
	{
		//titanLoadoutIndex = GetTitanLoadoutIndexByName(currentTitanLoadout.titanClass)
	}
/*
	print("------------------- edited Titan loadout")
	 int loadoutIndex = GetTitanLoadoutIndexByName(newTitanLoadout.titanClass)
	TitanLoadoutDef loadout = GetTitanLoadoutFromPersistentData( player, loadoutIndex )
	print("----------------" + loadout.passive1 + " \n" +loadout.passive2 + " \n" +loadout.passive3 + " \n" +loadout.passive4 + " \n" +loadout.passive5 + " \n" +loadout.passive6 + " \n" )
	print( "-------------------------------------------------"+ GetPersistentLoadoutValue( player, "titan", loadoutIndex, "titanClass" ))


	TitanLoadoutDef Titanloadout = newTitanLoadout
    
	TitanStruct CheckingTitan = GetTitanStructByName(Titanloadout.titanClass)
	
	if(Titanloadout.titanClass == CheckingTitan.name && CheckingTitan.disabled == true )
	{
		shouldChangeTitanLoadout = true
		
		int loadoutIndex = GetTitanLoadoutIndexByName(newTitanLoadout.titanClass)

		// the fuck retuns vortex shield 
		print(Titanloadout.special + "<- current    sollte es sein -> " + GetTitanLoadoutFromPersistentData( player, loadoutIndex ).special)

		//Titanloadout.titanClass = GetFirstAvailableTitan().name

		if(Titanloadout.name == "Null")
		{
			svGlobal.forceDisableTitanfalls = false
			return
		}

		CheckingTitan = GetTitanStructByName(Titanloadout.titanClass)

		
//		int loadoutIndex = GetTitanLoadoutIndexByName(newTitanLoadout.titanClass)

	//	Titanloadout.primary = GetTitanLoadoutFromPersistentData( player, loadoutIndex ).primary
		//Titanloadout = GetTitanLoadoutFromPersistentData( player, loadoutIndex )
	}
	/*


		if( CheckingTitan.passive1 != "UNDEFINED" )
		{
			Titanloadout.passive1 = CheckingTitan.passive1
			shouldChangeTitanLoadout = true
		}

		if( CheckingTitan.passive2 != "UNDEFINED" )
		{
			Titanloadout.passive2 = CheckingTitan.passive2
			shouldChangeTitanLoadout = true
		}

		if( CheckingTitan.passive3 != "UNDEFINED" )
		{
			Titanloadout.passive3 = CheckingTitan.passive3
			shouldChangeTitanLoadout = true
		}

		if( CheckingTitan.core1 != "UNDEFINED" )
		{
			Titanloadout.passive4 = CheckingTitan.core1
			shouldChangeTitanLoadout = true
		}
		
		if( CheckingTitan.core2 != "UNDEFINED" )
		{
			Titanloadout.passive5 = CheckingTitan.core2
			shouldChangeTitanLoadout = true
		}
		
		if( CheckingTitan.core3 != "UNDEFINED" )
		{
			Titanloadout.passive6 = CheckingTitan.core3
			shouldChangeTitanLoadout = true
		}
	*/


	// could loop infinetly if I change it every time so need to be carefull 
	
	if(shouldChangeTitanLoadout)
	{
	 SetPersistentSpawnLoadoutIndex(player,"titan", titanLoadoutIndex)

	 SendHudMessage( player, "Titan Loadout changed", 2.5,-2.5,255,0,0, 255, 0, 4, 1 )
	}
}


TitanStruct function GetTitanStructByName(string TitanName)
{
  switch(TitanName)
  {
	  	case"ion" :
	return file.titanArray[0]

	case "scorch" :
	return file.titanArray[1]

	case "northstar":
	return file.titanArray[2]

	case "ronin" :
	return file.titanArray[3]

	case "tone" :
	return file.titanArray[4]

	case "legion" :
	return file.titanArray[5]

	case "vanguard" :
	return file.titanArray[6] 
	}
	print("Titan Name Out of Range")
	return file.titanArray[0]
}

BoostStruct function GetBoostStructById(var id)
{
	for(int i = 0; i < file.boostArray.len();i++)
	{
		if(file.boostArray[i].id == id) 
		{
			return file.boostArray[i]
		}
	}
	return file.boostArray[0]
}